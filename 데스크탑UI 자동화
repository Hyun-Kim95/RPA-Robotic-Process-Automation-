# 환경설정
  설치: pip install pyautogui
  설치됐는지 확인: 
      import pyautogui

      size = pyautogui.size() # 현재 화면의 스크린 사이즈를 가져옴
      print(size)             # 가로, 세로 크기를 알 수 있음
      # size[0]: width
      # size[1]: height

# 마우스 이동
  # 절대 좌표로 마우스 이동
    pyautogui.moveTo(200,100)                # 지정한 위치(가로 x, 세로 y)로 마우스를 이동
    pyautogui.moveTo(100,200, duration=5)    # 5초 동안 100,200 위치로 이동

  # 상대 좌표로 마우스 이동(현재 커서가 있는 위치로부터)
    pyautogui.moveTo(100,100, duration=0.25)  # 절대
    pyautogui.move(100,100, duration=0.25)    # 상대
    pyautogui.move(100,100, duration=0.25)    # 상대

   # 포인터 위치 얻는 방법
    print(pyautogui.position())   # point(x, y)
    p = pyautogui.position()
    print(p[0], p[1])             # x, y
    print(p.x, p.y)               # x, y

# 마우스 액션
    pyautogui.sleep(3)  # 3초 대기
    
    pyautogui.click(1017, 19, duration=1)   # 1초 동안 (1017,19) 좌표를 마우스 클릭
    pyautogui.click()
    pyautogui.mouseDown()
    pyautogui.mouseUp()
    
    pyautogui.doubleClick()
    pyautogui.click(clicks=500) # 500번 클릭
    
    pyautogui.moveTo(200,200)
    pyautogui.mouseDown()   # 마우스 버튼 누른 상태
    pyautogui.moveTo(300,300)
    pyautogui.mouseUp()     # 마우스 버튼 뗀 상태
    
    pyautogui.rightClick()
    pyautogui.middleClick()
    
    pyautogui.moveTo(734,735)
    pyautogui.drag(100,0)   # 현재 위치 기준으로 x 100 만큼, y 0 만큼 드래그
    pyautogui.drag(100,0, duration=0.25)    # 너무 빠른 동작으로 drag 수행이 안될때는 duration 값 설정
    pyautogui.dragTo(1134,735, duration=0.25)  # 절대 좌표 기준으로 x 1134, y 735 로 드래그

    pyautogui.scroll(800)   # 양수이면 위 방향으로, 음수이면 아래 방향으로 800만큼 스크롤

# 마우스 정보
    pyautogui.mouseInfo()   #원하는 자리에서 F1을 누르고 3초 기다리면 좌표, rgb컬러가 복사됨
    # 붙혀넣기 결과: 1022,10 144,144,145 #909091
    
    pyautogui.PAUSE = 1     # 모든 동작에 1초씩 sleep 적용
    
    for i in range(5):     # fail-safe : 멈추고 싶을때 귀퉁이로 마우스 옮기면 멈추는 기본기능
    pyautogui.move(100,100)
    pyautogui.FAILSAFE = False  # fail-safe를 사용하지 않겠다는 의미임(비추)

# 스크린
  스크린 샷 찍기
    img = pyautogui.screenshot()
    img.save("screenshot.png")  # 파일로 저장
    
  마우스 위치가 정말 맞는지 확인
    # pyautogui.mouseInfo()   # 983,16 34,166,241 #22A6F1     # 원하는 마우스 위치 확인
    pixel = pyautogui.pixel(983, 16)
    print(pixel)                                              # rgb 값이 나옴 (34,166,241)
    print(pyautogui.pixelMatchesColor(983, 16, (34,166,241))) # True
    print(pyautogui.pixelMatchesColor(983, 16, (pixel)))      # True
    print(pyautogui.pixelMatchesColor(983, 16, (34,166,242))) # False

# 이미지 처리 - 기본
    file_menu = pyautogui.locateOnScreen("file_menu.png") # 이미지 찾기(중복이 있어도 처음 찾아지는것만 찾고 끝)
    print(file_menu)                                      # Box(left=999, top=8, width=39, height=16) 위치와 크기를 나타냄
    pyautogui.click(file_menu)                            # 찾은 위치를 클릭
    
    screen = pyautogui.locateOnScreen("screenshot.png")
    print(screen)                                         # 찾을 수 없으면 None
    
    for i in pyautogui.locateAllOnScreen("checkbox.png"): # 중복된 값을 모두 찾을 때에 사용
      print(i)                                            # 위치정보 반환
      pyautogui.click(i, duration=0.25)                   # 찾은것을 다 클릭

# 이미지 처리 - 속도 개선
  1. GrayScale(정확도는 조금 떨어질 수 있음)
    trash_icon = pyautogui.locateOnScreen("trash_icon.png", grayscale=True) # 화면을 흑백으로 바꾼 후 찾음
    pyautogui.moveTo(trash_icon)

  2. 범위 지정
    trash_icon = pyautogui.locateOnScreen("trash_icon.png", region=(1539,784,1893-1539,873-784))
    pyautogui.moveTo(trash_icon)
    # pyautogui.mouseInfo() # 찾은 값: 1539,784(근처 왼쪽 위) / 1893,873(근처 오른쪽 아래)

  3. 정확도 조정 # pip install opencv-python 설치
    run_btn = pyautogui.locateOnScreen("run_btn.png", confidence=0.9)   # 90%일치(기본값은0.999)
    pyautogui.moveTo(run_btn)

# 이미지 처리 - 대기
  1. 계속 기다리기
    file_menu_notepad = pyautogui.locateOnScreen("file_menu_notepad.png")
    if file_menu_notepad:
        pyautogui.click(file_menu_notepad)
    else:
        print("발견 실패")
        
    while file_menu_notepad is None:
        file_menu_notepad = pyautogui.locateOnScreen("file_menu_notepad.png")
        print("발견 실패")

    pyautogui.click(file_menu_notepad)

  2. 일정 시간동안 기다리기 (TimeOut)
    import time
    import sys

    timeout = 10          # 10초 대기
    start = time.time()   # 시작 시간 설정(UTC)
    file_menu_notepad = None
    while file_menu_notepad is None:
        file_menu_notepad = pyautogui.locateOnScreen("file_menu_notepad.png")
        end = time.time()           # 종료 시간 설정
        if end - start > timeout:   # 지정한 10초를 초과하면
            print("시간 종료")
            sys.exit()              # 프로그램을 종료
    pyautogui.click(file_menu_notepad)

  * 함수화 시키기
    import time
    import sys
    
    def find_target(img_file, timeout=30):
        start = time.time()
        target = None
        while target is None:
            target = pyautogui.locateOnScreen(img_file)
            end = time.time()
            if end - start > timeout:
                break
        return target

    def my_click(img_file, timeout=30):
        target = find_target(img_file, timeout)
        if target:
            pyautogui.click(target)
        else:
            print(f"[Timeout {timeout}s] Target not found ({img_file}). Terminate program.")
            sys.exit()

    my_click("file_menu_notepad.png", 10)

# 윈도우 다루기
    fw = pyautogui.getActiveWindow()    # 현재 활성화된 창 (VScode)
    print(fw.title)                     # 창의 제목 정보
    print(fw.size)                      # 창의 크기 정보(width, height)
    print(fw.left, fw.top, fw.right, fw.bottom) # 창의 좌표 정보
    pyautogui.click(fw.left + 25, fw.top + 20)  # 창의 좌표를 기준으로 가능

    for w in pyautogui.getAllWindows():                  # 실행중인 모든 윈도우 가져오기
        print(w)

    for w in pyautogui.getWindowsWithTitle("제목 없음"):  # 특정 이름을 가진것들 가져오기
        print(w)

    w = pyautogui.getWindowsWithTitle("제목 없음")[0]     # 특정 이름을 가진것들 중에 처음꺼 가져오기
    print(w)
    if w.isActive == False:     # 현재 활성화가 되지 않았다면
        w.activate()            #활성화 (맨 앞으로 가져오기)

    if w.isMaximized == False:  # 현재 최대화가 되지 않았다면
        w.maximize()            # 최대화

    pyautogui.sleep(1)          # 1초 쉼

    # if w.isMinimized == False:  # 현재 최소화가 되지 않았다면
    #     w.minimize()            # 최소화

    w.restore() # 화면 원복

    w.close()   # 윈도우 닫기

# 키보드
